/*
* @Author: Joakim
* @Year: 2022
* @Description:
* File is used to create test data, network setup for test and
* tracing of the messages for the test.
 */

package test

import (
	"context"
	"log"
	"math/rand"
	"time"

	"github.com/goombaio/namegenerator"
	pubsub "github.com/libp2p/go-libp2p-pubsub"
	"github.com/libp2p/go-libp2p/core/host"
	"github.com/libp2p/go-libp2p/core/peer"
	multiaddr "github.com/multiformats/go-multiaddr"
	"github.com/testground/sdk-go/network"
	"github.com/testground/sdk-go/runtime"
	"github.com/testground/sdk-go/sync"
)

/*
* Description: This function creates a random username based on the seed.
* @dev Return a random name generated by the package namegenerator.
* @return value of 'string'
 */
func GenName() string {
	seed := time.Now().UTC().UnixNano()
	nameGenerator := namegenerator.NewNameGenerator(seed)
	name := nameGenerator.Generate()

	return name
}

/*
* Description: This function creates a seed value which is random
* in the form of a integer 64 bytes.
* @dev Return a random seed of 64 Bytes .
* @return value of 'integer 64 bytes'
 */
func GenSeed() int64 {
	seed := time.Now().UTC().UnixNano()
	rand.Seed(seed)
	randSeed := rand.Int63()

	return randSeed
}

/*
* Description: This function creates network an sync environment for the test.
* Where it first sets up the envinronment for syncing for the test nodes.
* Then it generates the network with a bandwidth of 4913 bit and initalizes it
* through the runenv variable which is a pointer.
* @dev Return nothing.
* @return value of 'nothing'
 */
func GenNetAndSync(runenv *runtime.RunEnv, ctxBackground context.Context) error {
	// Create a client which will sync with the runtime environment
	syncClient, err := sync.NewBoundClient(ctxBackground, runenv)
	if err != nil {
		log.Printf("%s", err)
		return err
	}
	defer syncClient.Close()

	// Create a new network client based on the runtime environment and initalizes it
	netclient := network.NewClient(syncClient, runenv)
	netclient.MustWaitNetworkInitialized(ctxBackground)
	runenv.RecordMessage("network initilization complete")

	// Set max bandwidth to aproximatly 4913 bit message size to test IoT network
	maxMessageSize := 4913

	// Configure the network with a link with a speicfic bandwidth and allow all routing
	netconfig := network.Config{
		Network:       "default",
		Enable:        true,
		RoutingPolicy: network.RoutingPolicyType("allow_all"),
		Default: network.LinkShape{
			Bandwidth: uint64(maxMessageSize), // aproximatly 4913 bitrate/s
		},
		// Set what state the sidecar should signal back to you when it's done.
		CallbackState: "network initialisation successful",
	}

	// Initalize the network
	err = netclient.ConfigureNetwork(ctxBackground, &netconfig)
	if err != nil {
		return err
	}

	return nil
}

/*
* Description: This function creates a remote tracer to the given multi-address.
* It needs to be set to an address that can rescive the remote traces.
* @dev Return a struct for a remote tracer and nil or error message on failure.
* @return value of 'pointer to a RemoteTracer and error'
 */
func PubsubTrace(ctxBackground context.Context, host host.Host) (*pubsub.RemoteTracer, error) {
	// Setup remote tracer address
	address, err := peer.AddrInfoFromP2pAddr(
		multiaddr.StringCast("/ip4/192.168.2.11/tcp/50000/p2p/QmVGTEF9andGTahtMKDyd1odqyjTCT5Cja74qDGSbdSNQN"),
	)
	if err != nil {
		panic(err)
	}

	// Create a variable with correct format to store multi-address for the tracer
	pi := peer.AddrInfo{}
	pi.ID = address.ID
	pi.Addrs = address.Addrs

	// Return a tracer which uses the libp2p host to send tracer logs
	return pubsub.NewRemoteTracer(ctxBackground, host, pi)
}
